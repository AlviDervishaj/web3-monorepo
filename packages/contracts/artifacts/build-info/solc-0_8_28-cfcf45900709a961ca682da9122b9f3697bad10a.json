{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-cfcf45900709a961ca682da9122b9f3697bad10a",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Counter.sol": "project/contracts/Counter.sol",
    "contracts/Crowdfunding.sol": "project/contracts/Crowdfunding.sol",
    "contracts/CrowdfundingFactory.sol": "project/contracts/CrowdfundingFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Counter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract Counter {\n    uint256 public x;\n\n    event Increment(uint256 by);\n\n    function inc() external {\n        incBy(1);\n    }\n\n    function incBy(uint256 by) public {\n        x += by;\n        emit Increment(by);\n    }\n}\n\n"
      },
      "project/contracts/Crowdfunding.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Crowdfunding {\n    string public name;\n    string public description;\n    uint256 public goal;\n    uint256 public deadline;\n    address public owner;\n    bool public paused;\n    bool public underReview;\n    address public factory;\n\n    uint256 public withdrawalRequestTime;\n    bool public withdrawalApproved;\n    uint256 public constant WITHDRAWAL_DELAY = 1 days;\n\n    enum CampaignState { Active, Successful, Failed }\n    CampaignState public state;\n\n    struct Tier {\n        string name;\n        uint256 amount;\n        uint256 backers;\n    }\n\n    struct Backer {\n        uint256 totalContribution;\n        mapping(uint256 => bool) fundedTiers;\n    }\n\n    Tier[] public tiers;\n    mapping(address => Backer) public backers;\n\n    event FactoryPauseToggled(bool paused);\n    event UnderReviewToggled(bool underReview);\n    event WithdrawalRequested(uint256 requestedAt);\n    event WithdrawalApproved(uint256 approvedAt);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    modifier onlyFactory() {\n        require(msg.sender == factory, \"Not factory\");\n        _;\n    }\n\n    modifier campaignOpen() {\n        require(state == CampaignState.Active, \"Campaign is not active.\");\n        _;\n    }\n\n    modifier notPaused() {\n        require(!paused, \"Contract is paused.\");\n        _;\n    }\n    \n    constructor(\n        address _owner,\n        string memory _name,\n        string memory _description,\n        uint256 _goal,\n        uint256 _duratyionInDays\n    ) {\n        factory = msg.sender;\n        name = _name;\n        description = _description;\n        goal = _goal;\n        deadline = block.timestamp + (_duratyionInDays * 1 days);\n        owner = _owner;\n        state = CampaignState.Active;\n    }\n\n    function checkAndUpdateCampaignState() internal {\n        if(state == CampaignState.Active) {\n            if(block.timestamp >= deadline) {\n                state = address(this).balance >= goal ? CampaignState.Successful : CampaignState.Failed;            \n            } else {\n                state = address(this).balance >= goal ? CampaignState.Successful : CampaignState.Active;\n            }\n        }\n    }\n\n    function fund(uint256 _tierIndex) public payable campaignOpen notPaused {\n        require(!underReview, \"Campaign under review.\");\n        require(_tierIndex < tiers.length, \"Invalid tier.\");\n        require(msg.value == tiers[_tierIndex].amount, \"Incorrect amount.\");\n\n        tiers[_tierIndex].backers++;\n        backers[msg.sender].totalContribution += msg.value;\n        backers[msg.sender].fundedTiers[_tierIndex] = true;\n\n        checkAndUpdateCampaignState();\n    }\n\n    function addTier(\n        string memory _name,\n        uint256 _amount\n    ) public onlyOwner {\n        require(_amount > 0, \"Amount must be greater than 0.\");\n        tiers.push(Tier(_name, _amount, 0));\n    }\n\n    function removeTier(uint256 _index) public onlyOwner {\n        require(_index < tiers.length, \"Tier does not exist.\");\n        tiers[_index] = tiers[tiers.length -1];\n        tiers.pop();\n    }\n\n    function requestWithdrawal() public onlyOwner {\n        checkAndUpdateCampaignState();\n        require(state == CampaignState.Successful, \"Campaign not successful.\");\n        withdrawalRequestTime = block.timestamp;\n        withdrawalApproved = false;\n        emit WithdrawalRequested(withdrawalRequestTime);\n    }\n\n    function withdraw() public onlyOwner {\n        checkAndUpdateCampaignState();\n        require(state == CampaignState.Successful, \"Campaign not successful.\");\n        require(withdrawalRequestTime != 0, \"Withdrawal not requested\");\n        require(\n            block.timestamp >= withdrawalRequestTime + WITHDRAWAL_DELAY,\n            \"Withdrawal delay not met\"\n        );\n        require(withdrawalApproved, \"Withdrawal not approved\");\n\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No balance to withdraw\");\n\n        payable(owner).transfer(balance);\n        withdrawalRequestTime = 0;\n        withdrawalApproved = false;\n    }\n\n    function getContractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function refund() public {\n        checkAndUpdateCampaignState();\n        require(state == CampaignState.Failed, \"Refunds not available.\");\n        uint256 amount = backers[msg.sender].totalContribution;\n        require(amount > 0, \"No contribution to refund\");\n\n        backers[msg.sender].totalContribution = 0;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function hasFundedTier(address _backer, uint256 _tierIndex) public view returns (bool) {\n        return backers[_backer].fundedTiers[_tierIndex];\n    }\n\n    function getTiers() public view returns (Tier[] memory) {\n        return tiers;\n    }\n\n    function togglePause() public onlyOwner {\n        paused = !paused;\n    }\n\n    function setPauseFromFactory(bool _paused) external onlyFactory {\n        paused = _paused;\n        emit FactoryPauseToggled(_paused);\n    }\n\n    function setUnderReview(bool _underReview) external onlyFactory {\n        underReview = _underReview;\n        emit UnderReviewToggled(_underReview);\n    }\n\n    function getCampaignStatus() public view returns (CampaignState) {\n        if (state == CampaignState.Active && block.timestamp > deadline) {\n            return address(this).balance >= goal ? CampaignState.Successful : CampaignState.Failed;\n        }\n        return state;\n    }\n\n    function extendDeadline(uint256 _daysToAdd) public onlyOwner campaignOpen {\n        deadline += _daysToAdd * 1 days;\n    }\n\n    function factoryApproveWithdrawal() external onlyFactory {\n        withdrawalApproved = true;\n        emit WithdrawalApproved(block.timestamp);\n    }\n}"
      },
      "project/contracts/CrowdfundingFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Crowdfunding} from \"./Crowdfunding.sol\";\n\ncontract CrowdfundingFactory {\n    address public owner;\n    bool public paused;\n    mapping(address => bool) public campaignPaused;\n    mapping(address => bool) public campaignUnderReview;\n    mapping(address => uint256) public campaignLastWithdrawalApproval;\n\n    struct Campaign {\n        address campaignAddress;\n        address owner;\n        string name;\n        uint256 creationTime;\n    }\n\n    Campaign[] public campaigns;\n    mapping(address => Campaign[]) public userCampaigns;\n\n    event CampaignPaused(address indexed campaign, bool isPaused);\n    event CampaignUnderReview(address indexed campaign, bool underReview);\n    event CampaignWithdrawalApproved(address indexed campaign, uint256 approvedAt);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner.\");\n        _;\n    }\n\n    modifier notPaused() {\n        require(!paused, \"Factory is paused\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function createCampaign(\n        string memory _name,\n        string memory _description,\n        uint256 _goal,\n        uint256 _durationInDays\n    ) external notPaused {\n        Crowdfunding newCampaign = new Crowdfunding(\n            msg.sender,\n            _name,\n            _description,\n            _goal,\n            _durationInDays\n        );\n        address campaignAddress = address(newCampaign);\n\n        Campaign memory campaign = Campaign({\n            campaignAddress: campaignAddress,\n            owner: msg.sender,\n            name: _name,\n            creationTime: block.timestamp\n        });\n\n        campaigns.push(campaign);\n        userCampaigns[msg.sender].push(campaign);\n    }\n\n    function getUserCampaigns(address _user) external view returns (Campaign[] memory) {\n        return userCampaigns[_user];\n    }\n\n    function getAllCampaigns() external view returns (Campaign[] memory) {\n        return campaigns;\n    }\n\n    function togglePause() external onlyOwner {\n        paused = !paused;\n    }\n\n    function setCampaignPause(address _campaign, bool _shouldPause) external onlyOwner {\n        require(_campaign != address(0), \"Invalid campaign\");\n        Crowdfunding(_campaign).setPauseFromFactory(_shouldPause);\n        campaignPaused[_campaign] = _shouldPause;\n        emit CampaignPaused(_campaign, _shouldPause);\n    }\n\n    function setCampaignUnderReview(address _campaign, bool _underReview) external onlyOwner {\n        require(_campaign != address(0), \"Invalid campaign\");\n        Crowdfunding(_campaign).setUnderReview(_underReview);\n        campaignUnderReview[_campaign] = _underReview;\n        emit CampaignUnderReview(_campaign, _underReview);\n    }\n\n    function approveCampaignWithdrawal(address _campaign) external onlyOwner {\n        require(_campaign != address(0), \"Invalid campaign\");\n        Crowdfunding(_campaign).factoryApproveWithdrawal();\n        campaignLastWithdrawalApproval[_campaign] = block.timestamp;\n        emit CampaignWithdrawalApproved(_campaign, block.timestamp);\n    }\n\n    function getCampaignGovernance(\n        address _campaign\n    )\n        external\n        view\n        returns (\n            bool isPaused,\n            bool isUnderReview,\n            uint256 lastWithdrawalApproval\n        )\n    {\n        return (\n            campaignPaused[_campaign],\n            campaignUnderReview[_campaign],\n            campaignLastWithdrawalApproval[_campaign]\n        );\n    }\n}"
      }
    }
  }
}